#!/usr/bin/env python3
"""
Tests for the match list change detector.

Verifies that the change detector correctly identifies changes in match lists.
"""

import json
import os
import shutil
import subprocess
import tempfile
import unittest
from unittest.mock import MagicMock, patch

# Mock the imports that would cause issues
with patch("sys.modules", {"fogis_api_client": MagicMock()}):
    # Now import the module to test
    from pathlib import Path

    from match_list_change_detector import PREVIOUS_MATCHES_FILE, MatchListChangeDetector


class TestMatchListChangeDetector(unittest.TestCase):
    """Test cases for the MatchListChangeDetector class."""

    def setUp(self):
        """Set up test fixtures."""
        # Create a temporary directory for test files
        self.test_dir = tempfile.mkdtemp()
        self.old_cwd = os.getcwd()
        os.chdir(self.test_dir)

        # Sample match data
        self.sample_match = {
            "matchid": 6169105,
            "matchnr": "000024032",
            "speldatum": "2025-04-26",
            "avsparkstid": "14:00",
            "lag1lagid": 25650,
            "lag1namn": "IK Kongahälla",
            "lag2lagid": 25529,
            "lag2namn": "Motala AIF FK",
            "anlaggningnamn": "Kongevi 1 Konstgräs",
            "installd": False,
            "avbruten": False,
            "uppskjuten": False,
            "domaruppdraglista": [
                {
                    "domareid": 6600,
                    "personnamn": "Bartek Svaberg",
                    "domarrollnamn": "Huvuddomare",
                    "epostadress": "bartek.svaberg@gmail.com",
                    "mobiltelefon": "0709423055",
                }
            ],
        }

        # Create a detector instance with mocked API client
        self.api_client_mock = MagicMock()
        self.detector = MatchListChangeDetector("test_user", "test_pass")
        self.detector.api_client = self.api_client_mock

    def tearDown(self):
        """Tear down test fixtures."""
        os.chdir(self.old_cwd)
        shutil.rmtree(self.test_dir)

    def test_load_previous_matches_file_exists(self):
        """Test loading previous matches when the file exists."""
        # Create a sample previous matches file
        sample_matches = [self.sample_match]
        with open(PREVIOUS_MATCHES_FILE, "w") as f:
            json.dump(sample_matches, f)

        # Load the previous matches
        result = self.detector.load_previous_matches()

        # Verify the result
        self.assertTrue(result)
        self.assertEqual(len(self.detector.previous_matches), 1)
        self.assertEqual(self.detector.previous_matches[0]["matchid"], 6169105)

    def test_load_previous_matches_file_not_exists(self):
        """Test loading previous matches when the file doesn't exist."""
        # Make sure the file doesn't exist
        if os.path.exists(PREVIOUS_MATCHES_FILE):
            os.remove(PREVIOUS_MATCHES_FILE)

        # Load the previous matches
        result = self.detector.load_previous_matches()

        # Verify the result
        self.assertFalse(result)
        self.assertEqual(len(self.detector.previous_matches), 0)

    def test_save_current_matches(self):
        """Test saving current matches to file."""
        # Set up current matches
        self.detector.current_matches = [self.sample_match]

        # Save the current matches
        result = self.detector.save_current_matches()

        # Verify the result
        self.assertTrue(result)
        self.assertTrue(os.path.exists(PREVIOUS_MATCHES_FILE))

        # Verify the file contents
        with open(PREVIOUS_MATCHES_FILE, "r") as f:
            saved_matches = json.load(f)
        self.assertEqual(len(saved_matches), 1)
        self.assertEqual(saved_matches[0]["matchid"], 6169105)

    @patch("match_list_change_detector.MatchListFilter")
    def test_fetch_current_matches_success(self, mock_match_list_filter):
        """Test fetching current matches successfully."""
        # Set up the mock
        mock_filter_instance = MagicMock()
        mock_match_list_filter.return_value = mock_filter_instance
        mock_filter_instance.start_date.return_value = mock_filter_instance
        mock_filter_instance.end_date.return_value = mock_filter_instance
        mock_filter_instance.fetch_filtered_matches.return_value = [self.sample_match]

        # Fetch current matches
        result = self.detector.fetch_current_matches()

        # Verify the result
        self.assertTrue(result)
        self.assertEqual(len(self.detector.current_matches), 1)
        self.assertEqual(self.detector.current_matches[0]["matchid"], 6169105)

        # Verify the API client was used correctly
        self.api_client_mock.login.assert_called_once()
        mock_filter_instance.fetch_filtered_matches.assert_called_once_with(self.api_client_mock)

    @patch("match_list_change_detector.MatchListFilter")
    def test_fetch_current_matches_failure(self, mock_match_list_filter):
        """Test fetching current matches with a failure."""
        # Set up the mock to raise an exception
        self.api_client_mock.login.side_effect = Exception("Login failed")

        # Fetch current matches
        result = self.detector.fetch_current_matches()

        # Verify the result
        self.assertFalse(result)
        self.assertEqual(len(self.detector.current_matches), 0)

    def test_detect_changes_no_previous_matches(self):
        """Test detecting changes when there are no previous matches."""
        # Set up the detector
        self.detector.previous_matches = []
        self.detector.current_matches = [self.sample_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertTrue(has_changes)
        self.assertEqual(changes["new_matches"], 1)
        self.assertIn("message", changes)

    def test_detect_changes_new_match(self):
        """Test detecting a new match."""
        # Set up the detector
        self.detector.previous_matches = []
        self.detector.current_matches = [self.sample_match]

        # Add a previous match with a different ID
        prev_match = self.sample_match.copy()
        prev_match["matchid"] = 6169106
        self.detector.previous_matches = [prev_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertTrue(has_changes)
        self.assertEqual(changes["new_matches"], 1)
        self.assertEqual(changes["removed_matches"], 1)
        self.assertEqual(len(changes["new_match_details"]), 1)
        self.assertEqual(len(changes["removed_match_details"]), 1)

    def test_detect_changes_removed_match(self):
        """Test detecting a removed match."""
        # Set up the detector
        self.detector.current_matches = []
        self.detector.previous_matches = [self.sample_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertTrue(has_changes)
        self.assertEqual(changes["new_matches"], 0)
        self.assertEqual(changes["removed_matches"], 1)
        self.assertEqual(len(changes["new_match_details"]), 0)
        self.assertEqual(len(changes["removed_match_details"]), 1)

    def test_detect_changes_time_change(self):
        """Test detecting a change in match time."""
        # Set up the detector with a previous match
        self.detector.previous_matches = [self.sample_match]

        # Create a current match with a different time
        current_match = self.sample_match.copy()
        current_match["avsparkstid"] = "15:00"
        self.detector.current_matches = [current_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertTrue(has_changes)
        self.assertEqual(changes["new_matches"], 0)
        self.assertEqual(changes["removed_matches"], 0)
        self.assertEqual(changes["changed_matches"], 1)
        self.assertEqual(len(changes["changed_match_details"]), 1)
        self.assertEqual(changes["changed_match_details"][0]["previous"]["time"], "14:00")
        self.assertEqual(changes["changed_match_details"][0]["current"]["time"], "15:00")
        self.assertTrue(changes["changed_match_details"][0]["changes"]["basic"])

    def test_detect_changes_venue_change(self):
        """Test detecting a change in match venue."""
        # Set up the detector with a previous match
        self.detector.previous_matches = [self.sample_match]

        # Create a current match with a different venue
        current_match = self.sample_match.copy()
        current_match["anlaggningnamn"] = "New Venue"
        self.detector.current_matches = [current_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertTrue(has_changes)
        self.assertEqual(changes["changed_matches"], 1)
        self.assertEqual(
            changes["changed_match_details"][0]["previous"]["venue"], "Kongevi 1 Konstgräs"
        )
        self.assertEqual(changes["changed_match_details"][0]["current"]["venue"], "New Venue")

    def test_detect_changes_referee_change(self):
        """Test detecting a change in match referees."""
        # Set up the detector with a previous match
        self.detector.previous_matches = [self.sample_match]

        # Create a current match with a different referee
        current_match = self.sample_match.copy()
        current_match["domaruppdraglista"] = [
            {
                "domareid": 7700,  # Different referee ID
                "personnamn": "Another Referee",
                "domarrollnamn": "Huvuddomare",
                "epostadress": "another@example.com",
                "mobiltelefon": "1234567890",
            }
        ]
        self.detector.current_matches = [current_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertTrue(has_changes)
        self.assertEqual(changes["changed_matches"], 1)
        self.assertTrue(changes["changed_match_details"][0]["changes"]["referees"])

    def test_detect_changes_no_changes(self):
        """Test detecting no changes."""
        # Set up the detector with identical previous and current matches
        self.detector.previous_matches = [self.sample_match]
        self.detector.current_matches = [self.sample_match]

        # Detect changes
        has_changes, changes = self.detector.detect_changes()

        # Verify the result
        self.assertFalse(has_changes)
        self.assertEqual(changes["new_matches"], 0)
        self.assertEqual(changes["removed_matches"], 0)
        self.assertEqual(changes["changed_matches"], 0)

    @patch("match_list_change_detector.subprocess.run")
    @patch("match_list_change_detector.get_executable_path")
    @patch("match_list_change_detector.validate_file_path")
    def test_trigger_docker_compose_success(self, mock_validate, mock_get_exec, mock_run):
        """Test triggering docker-compose successfully."""
        # Set up the mocks
        mock_process = MagicMock()
        mock_process.returncode = 0
        mock_run.return_value = mock_process
        mock_get_exec.return_value = "/usr/bin/docker-compose"
        mock_validate.return_value = Path("match_changes.json")

        # Create a changes dictionary
        changes = {
            "new_matches": 1,
            "removed_matches": 0,
            "changed_matches": 0,
            "new_match_details": [self.sample_match],
            "removed_match_details": [],
            "changed_match_details": [],
        }

        # Trigger docker-compose
        result = self.detector.trigger_docker_compose(changes)

        # Verify the result
        self.assertTrue(result)
        mock_validate.assert_called()
        mock_get_exec.assert_called_once_with("docker-compose")
        mock_run.assert_called_once()

    @patch("match_list_change_detector.subprocess.run")
    @patch("match_list_change_detector.get_executable_path")
    @patch("match_list_change_detector.validate_file_path")
    def test_trigger_docker_compose_failure(self, mock_validate, mock_get_exec, mock_run):
        """Test triggering docker-compose with a failure."""
        # Set up the mocks
        mock_process = MagicMock()
        mock_process.returncode = 1
        mock_process.stderr = "Error"
        mock_run.return_value = mock_process
        mock_get_exec.return_value = "/usr/bin/docker-compose"
        mock_validate.return_value = Path("match_changes.json")

        # Create a changes dictionary
        changes = {
            "new_matches": 1,
            "removed_matches": 0,
            "changed_matches": 0,
            "new_match_details": [self.sample_match],
            "removed_match_details": [],
            "changed_match_details": [],
        }

        # Trigger docker-compose
        result = self.detector.trigger_docker_compose(changes)

        # Verify the result
        self.assertFalse(result)

    @patch("match_list_change_detector.subprocess.run")
    @patch("match_list_change_detector.get_executable_path")
    @patch("match_list_change_detector.validate_file_path")
    def test_trigger_docker_compose_timeout(self, mock_validate, mock_get_exec, mock_run):
        """Test triggering docker-compose with a timeout."""
        # Set up the mocks
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="docker-compose", timeout=30)
        mock_get_exec.return_value = "/usr/bin/docker-compose"
        mock_validate.return_value = Path("match_changes.json")

        # Create a changes dictionary
        changes = {
            "new_matches": 1,
            "removed_matches": 0,
            "changed_matches": 0,
            "new_match_details": [self.sample_match],
            "removed_match_details": [],
            "changed_match_details": [],
        }

        # Trigger docker-compose
        result = self.detector.trigger_docker_compose(changes)

        # Verify the result
        self.assertTrue(result)  # Should return True even with a timeout

    @patch.object(MatchListChangeDetector, "load_previous_matches")
    @patch.object(MatchListChangeDetector, "fetch_current_matches")
    @patch.object(MatchListChangeDetector, "detect_changes")
    @patch.object(MatchListChangeDetector, "trigger_docker_compose")
    @patch.object(MatchListChangeDetector, "save_current_matches")
    def test_run_success(self, mock_save, mock_trigger, mock_detect, mock_fetch, mock_load):
        """Test running the full change detection process successfully."""
        # Set up the mocks
        mock_load.return_value = True
        mock_fetch.return_value = True
        mock_detect.return_value = (True, {"changes": "detected"})
        mock_trigger.return_value = True
        mock_save.return_value = True

        # Run the detector
        result = self.detector.run()

        # Verify the result
        self.assertTrue(result)
        mock_load.assert_called_once()
        mock_fetch.assert_called_once()
        mock_detect.assert_called_once()
        mock_trigger.assert_called_once_with({"changes": "detected"})
        mock_save.assert_called_once()

    @patch.object(MatchListChangeDetector, "load_previous_matches")
    @patch.object(MatchListChangeDetector, "fetch_current_matches")
    @patch.object(MatchListChangeDetector, "detect_changes")
    @patch.object(MatchListChangeDetector, "trigger_docker_compose")
    @patch.object(MatchListChangeDetector, "save_current_matches")
    def test_run_no_changes(self, mock_save, mock_trigger, mock_detect, mock_fetch, mock_load):
        """Test running the process with no changes detected."""
        # Set up the mocks
        mock_load.return_value = True
        mock_fetch.return_value = True
        mock_detect.return_value = (False, {"changes": "none"})

        # Run the detector
        result = self.detector.run()

        # Verify the result
        self.assertTrue(result)
        mock_trigger.assert_not_called()  # Should not trigger docker-compose
        mock_save.assert_called_once()  # Should still save current matches

    @patch.object(MatchListChangeDetector, "load_previous_matches")
    @patch.object(MatchListChangeDetector, "fetch_current_matches")
    def test_run_fetch_failure(self, mock_fetch, mock_load):
        """Test running the process with a failure to fetch current matches."""
        # Set up the mocks
        mock_load.return_value = True
        mock_fetch.return_value = False

        # Run the detector
        result = self.detector.run()

        # Verify the result
        self.assertFalse(result)


if __name__ == "__main__":
    unittest.main()
